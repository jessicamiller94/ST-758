{
    "contents" : "### Jessica Miller ###\n### Nov. 10, 2016 ###\n### ST 758 Proj. 2 ###\n\n#setwd(\"F:/ST 758/jmmill13ST758\")\n#library(fields)\n#library(geoR)\n#library(mvtnorm)\n\nloc1024 <- read.csv(\"locations1024.csv\", header=T)\nloc2025 <- read.csv(\"locations2025.csv\", header=T)\nloc4096 <- read.csv(\"locations4096.csv\", header=T)\n\n## Plot locations on grid\n\nplot(loc1024[,1],loc1024[,2])\nplot(loc2025[,1],loc2025[,2])\nplot(loc4096[,1],loc4096[,2])\n\n# The locations are very similar to each other. Create grid.\n\nnewlocs <- function(locs.x, locs.y, sep) {\n    x1 <- seq(min(locs.x), max(locs.x), by=sep)\n    x2 <- seq(min(locs.y), max(locs.y), by=sep)\n    s   <- expand.grid(x1, x2)\n}\n\nnew1024 <- newlocs(loc1024[,1], loc1024[,2], .5)\nnew2025 <- newlocs(loc2025[,1], loc2025[,2], .5)\nnew4096 <- newlocs(loc4096[,1], loc4096[,2], .5)\n\n\nplot(loc1024[,1],loc1024[,2])\npoints(new1024[,1], new1024[,2], col=\"red\")\nplot(loc2025[,1],loc2025[,2])\npoints(new2025[,1], new2025[,2], col=\"red\")\nplot(loc4096[,1],loc4096[,2])\npoints(new4096[,1], new4096[,2], col=\"red\")\n\n# Calculate covariance matrices for new grid.\n\ndist1024 <- rdist(new1024)\ndist2025 <- rdist(new2025)\ndist4096 <- rdist(new4096)\n\ncovmat <- function(number, dist) {\n    if (number == 1) {\n        cov <- Matern(dist1024,1)\n    }\n    if (number == 2) {\n        cov <- exp(-dist)\n    }\n    return(cov)\n}\n\ncov1024.mat <- covmat(1,dist1024)\ncov2025.mat <- covmat(1,dist2025)\ncov4096.mat <- covmat(1,dist4096)\ncov1024.exp <- covmat(2,dist1024)\ncov2025.exp <- covmat(2,dist2025)\ncov4096.exp <- covmat(2,dist4096)\n\n# Calculate Gaussian log likelihood two different ways:\n# once using solve() to calculate inverse,\n# once using chol2inv() to calculate inverse.\n# Return the timing of each.\n\nloglik <- function(cov) {\n    y <- rmvnorm(n=nrow(cov), sigma=cov)\n    timing1 <- vector()\n    timing2 <- vector()\n    for (i in 1:nrow(cov)){\n        timing1 <- append(timing1, system.time(t(y[,i])%*%solve(cov)%*%y[,i])[3])\n        timing2 <- append(timing2, system.time(t(y[,i])%*%chol2inv(chol(cov))%*%y[,i])[3])\n    }\n    return(list(as.numeric(timing1),as.numeric(timing2)))\n}\n\nll1024.mat <- loglik(cov1024.mat)\nll1024.exp <- loglik(cov1024.exp)\nll2025.mat <- loglik(cov2025.mat)\nll2025.exp <- loglik(cov2025.exp)\nll4096.mat <- loglik(cov4096.mat)\nll4096.exp <- loglik(cov4096.exp)\n\nmean(ll1024.mat[[1]])\nmean(ll1024.exp[[1]])\nmean(ll1024.mat[[2]])\nmean(ll1024.exp[[2]])\nmean(ll2025.mat[[1]])\nmean(ll2025.exp[[1]])\nmean(ll2025.mat[[2]])\nmean(ll2025.exp[[2]])\nmean(ll4096.mat[[1]])\nmean(ll4096.exp[[1]])\nmean(ll4096.mat[[2]])\nmean(ll4096.exp[[2]])\n\n# Looks like chol2inv() is the faster way.\n# Create new grid for higher accuracy.\n\nnew2025.2 <- newlocs(loc2025[,1], loc2025[,2], .375)\nnew4096.2 <- newlocs(loc4096[,1], loc4096[,2], .25)\n\nplot(loc2025[,1],loc2025[,2])\npoints(new2025.2[,1], new2025.2[,2], col=\"red\")\nplot(loc4096[,1],loc4096[,2])\npoints(new4096.2[,1], new4096.2[,2], col=\"red\")\n\n# Use new grids to investigate the speeds of the log-likelihoods.\n\ndist2025.2 <- rdist(new2025.2)\ndist4096.2 <- rdist(new4096.2)\n\ncov2025.mat.2 <- covmat(1,dist2025.2)\ncov4096.mat.2 <- covmat(1,dist4096.2)\ncov2025.exp.2 <- covmat(2,dist2025.2)\ncov4096.exp.2 <- covmat(2,dist4096.2)\n\nll2025.mat.2 <- loglik(cov2025.mat.2)\nll2025.exp.2 <- loglik(cov2025.exp.2)\nll4096.mat.2 <- loglik(cov4096.mat.2)\nll4096.exp.2 <- loglik(cov4096.exp.2) ## Takes a long time!\n\nmean(ll2025.mat.2[[1]])\nmean(ll2025.exp.2[[1]])\nmean(ll2025.mat.2[[2]])\nmean(ll2025.exp.2[[2]])\nmean(ll4096.mat.2[[1]])\nmean(ll4096.exp.2[[1]])\nmean(ll4096.mat.2[[2]])\nmean(ll4096.exp.2[[2]])\n\n",
    "created" : 1481060900143.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1283925595",
    "id" : "35BF6F12",
    "lastKnownWriteTime" : 1481085448,
    "path" : "F:/ST 758/jmmill13ST758/jmmill13project2.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}